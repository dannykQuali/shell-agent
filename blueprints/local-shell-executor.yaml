spec_version: 2
description: |
  Execute shell commands directly on the Torque agent container.
  This blueprint runs commands locally on the agent without SSH to any remote host.
  Useful for running scripts, tools, or commands that don't require a target machine.

inputs:
  agent:
    type: agent
    description: The Torque agent to use for execution
  command_b64:
    type: string
    description: Base64-encoded shell command(s) to execute on the agent
  init_commands_b64:
    type: string
    description: Base64-encoded init commands (optional)
    default: ""
  finally_commands_b64:
    type: string
    description: Base64-encoded finally commands (optional)
    default: ""

outputs:
  command_output:
    value: '{{ .grains.local_executor.activities.deploy.commands.run_local.outputs.command_output }}'
  exit_code:
    value: '{{ .grains.local_executor.activities.deploy.commands.run_local.outputs.exit_code }}'

grains:
  local_executor:
    kind: shell
    spec:
      agent:
        name: '{{ .inputs.agent }}'
      activities:
        deploy:
          commands:
            - name: run_local
              command: |
                echo "=== Beginning of local execution ============================================================================================================="
                
                # Initialize variables for trap
                OUTPUT_FILE=$(mktemp)
                CMD_EXIT_CODE=1
                
                # Trap to ensure outputs are always exported, even on script failure
                __export_outputs() {
                  local trap_exit_code=$?
                  # Use CMD_EXIT_CODE if set, otherwise use the trap's exit code
                  local final_exit_code=${CMD_EXIT_CODE:-$trap_exit_code}
                  
                  # Export whatever output we captured (empty string if file doesn't exist or is empty)
                  if [ -f "$OUTPUT_FILE" ]; then
                    export command_output=$(base64 < "$OUTPUT_FILE" | tr -d '\n')
                  else
                    export command_output=""
                  fi
                  export exit_code="$final_exit_code"
                  
                  # Cleanup temp files
                  rm -f "$OUTPUT_FILE" "$SCRIPT_FILE" "$INIT_FILE" "$FINALLY_FILE" "$COMBINED" 2>/dev/null || true
                  
                  echo ""
                  echo "=== Command completed with exit code: $final_exit_code ==="
                }
                trap __export_outputs EXIT
                
                SCRIPT_FILE=$(mktemp)
                
                # Decode base64 inputs directly to files
                echo '{{ .inputs.command_b64 }}' | base64 -d > "$SCRIPT_FILE"
                
                INIT_FILE=$(mktemp)
                echo '{{ .inputs.init_commands_b64 }}' | base64 -d > "$INIT_FILE" 2>/dev/null || true
                
                FINALLY_FILE=$(mktemp)
                echo '{{ .inputs.finally_commands_b64 }}' | base64 -d > "$FINALLY_FILE" 2>/dev/null || true
                
                # Build combined script
                COMBINED=$(mktemp)
                echo '#!/bin/bash' > "$COMBINED"
                
                # Add finally trap if provided - wrapped with </dev/null to prevent stdin reads
                if [ -s "$FINALLY_FILE" ]; then
                  echo '__finally() {' >> "$COMBINED"
                  echo '(' >> "$COMBINED"
                  cat "$FINALLY_FILE" >> "$COMBINED"
                  echo '' >> "$COMBINED"
                  echo ') </dev/null' >> "$COMBINED"
                  echo '}' >> "$COMBINED"
                  echo 'trap __finally EXIT' >> "$COMBINED"
                fi
                
                # Add init commands if provided - use curly braces (not subshell) so exports persist
                # Redirect stdin to /dev/null to prevent interactive prompts
                if [ -s "$INIT_FILE" ]; then
                  echo "=== Running init commands ==="
                  echo '{' >> "$COMBINED"
                  cat "$INIT_FILE" >> "$COMBINED"
                  echo '' >> "$COMBINED"
                  echo '} </dev/null' >> "$COMBINED"
                fi
                
                # Add main command - wrapped with </dev/null to prevent stdin reads
                echo '(' >> "$COMBINED"
                cat "$SCRIPT_FILE" >> "$COMBINED"
                echo '' >> "$COMBINED"
                echo ') </dev/null' >> "$COMBINED"
                
                chmod +x "$COMBINED"
                
                echo "=== Executing on agent container ==="
                echo "=== Output (streaming) ========================================================================================================================="
                
                # Run the script (commands inside already have </dev/null protection)
                set +e
                bash "$COMBINED" 2>&1 | tee "$OUTPUT_FILE"
                CMD_EXIT_CODE=${PIPESTATUS[0]}
                # Trap will handle export and cleanup on exit
              outputs:
                - command_output
                - exit_code
