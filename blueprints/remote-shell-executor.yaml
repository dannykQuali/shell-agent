spec_version: 2
description: |
  Execute shell commands on a remote host via SSH.
  This blueprint is designed to be called programmatically by the ShellAgent MCP tool
  to enable Copilot to run commands on remote servers for troubleshooting.

inputs:
  agent:
    type: agent
    description: The Torque agent to use for execution
  target_ip:
    type: string
    description: The IP address or hostname of the target server
  ssh_user:
    type: string
    description: The SSH username to connect with
  ssh_private_key:
    type: string
    description: The SSH private key in PEM format for authentication
    sensitive: true
  command:
    type: string
    description: The shell command(s) to execute on the remote host
  init_commands:
    type: string
    description: Commands to run before the main command (e.g., proxy setup)
    default: ""
  finally_commands:
    type: string
    description: Commands to run after the main command (cleanup, always runs)
    default: ""

outputs:
  command_output:
    value: '{{ .grains.remote_executor.activities.deploy.commands.run_ssh.outputs.command_output }}'
  exit_code:
    value: '{{ .grains.remote_executor.activities.deploy.commands.run_ssh.outputs.exit_code }}'

grains:
  remote_executor:
    kind: shell
    spec:
      agent:
        name: '{{ .inputs.agent }}'
      activities:
        deploy:
          commands:
            - name: run_ssh
              command: |
                # Save the private key to temp file (key is passed as-is in PEM format)
                KEY_FILE=$(mktemp)
                cat << 'KEYEOF' > "$KEY_FILE"
                {{ .inputs.ssh_private_key }}
                KEYEOF
                chmod 600 "$KEY_FILE"
                
                # Prepare output file for capturing (while also streaming)
                OUTPUT_FILE=$(mktemp)
                
                # Build the full command with init and finally
                INIT_COMMANDS='{{ .inputs.init_commands }}'
                FINALLY_COMMANDS='{{ .inputs.finally_commands }}'
                MAIN_COMMAND='{{ .inputs.command }}'
                
                # Construct the remote script
                REMOTE_SCRIPT=""
                
                # Add init commands if provided
                if [ -n "$INIT_COMMANDS" ]; then
                  REMOTE_SCRIPT="$INIT_COMMANDS"$'\n'
                fi
                
                # Add main command with finally block if finally commands exist
                if [ -n "$FINALLY_COMMANDS" ]; then
                  # Use trap for cleanup that runs even on failure
                  REMOTE_SCRIPT="${REMOTE_SCRIPT}__cleanup() { $FINALLY_COMMANDS; }"$'\n'
                  REMOTE_SCRIPT="${REMOTE_SCRIPT}trap __cleanup EXIT"$'\n'
                fi
                
                # Add main command
                REMOTE_SCRIPT="${REMOTE_SCRIPT}${MAIN_COMMAND}"
                
                echo "=== Connecting to {{ .inputs.ssh_user }}@{{ .inputs.target_ip }} ==="
                if [ -n "$INIT_COMMANDS" ]; then
                  echo "=== Init commands configured ==="
                fi
                echo "=== Executing: {{ .inputs.command }} ==="
                echo "=== Output (streaming) ==="
                
                # Run the SSH command with output streaming via tee
                # This shows output in real-time in Torque logs while also capturing it
                set +e
                ssh -o StrictHostKeyChecking=no \
                    -o UserKnownHostsFile=/dev/null \
                    -o LogLevel=ERROR \
                    -i "$KEY_FILE" \
                    "{{ .inputs.ssh_user }}@{{ .inputs.target_ip }}" \
                    "$REMOTE_SCRIPT" 2>&1 | tee "$OUTPUT_FILE"
                SSH_EXIT_CODE=${PIPESTATUS[0]}
                set -e
                
                # Read captured output
                COMMAND_OUTPUT=$(cat "$OUTPUT_FILE")
                
                # Cleanup
                rm -f "$KEY_FILE" "$OUTPUT_FILE"
                
                # Export outputs for Torque to capture
                export command_output="$COMMAND_OUTPUT"
                export exit_code="$SSH_EXIT_CODE"
                
                echo ""
                echo "=== Command completed with exit code: $SSH_EXIT_CODE ==="
              outputs:
                - command_output
                - exit_code
